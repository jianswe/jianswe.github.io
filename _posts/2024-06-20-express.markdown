# Express.js

## Routes
### CRUD
* `GET product/:id` - get a product by a given ID
* `GET product` - get all the products (for an authenticated user)
* `POST product` - create a new product
* `PUT product/:id` - update or replace a product that matches a given ID
* `DELETE product/:id` - delete a product by a given ID

### Create routes 
Create a new file, `src/router.ts`
```js
import { Router } from 'express'
import { createProduct, deleteProduct, getOneProduct, getProducts } from './handlers/product'

const router = Router() // router is like a sub app

/**
 * Product
 */
router.get('/product', getProducts) // The route handlers will be created later 
router.get('/product/:id', getOneProduct) 
router.put('/product/:id', () => {})
router.post('/product', createProduct)
router.delete('/product/:id', deleteProduct)

export default router 
```

Mount `router` to `app`. 
Go back to `src/server.ts` 
```js
import router from './router'

const app = express()

app.use('/api', router) // /api/product

export default app
```

### Testing the API 
Testing the API with Thunder Client (VS code plugin) or Postman.    
Example: GET http://localhost:3001/api/product     
will get 
```
{
  "message": "hello"
}
```

### Route Handlers
Create `src/handlers/product.ts`
```ts
import prisma from '../db'

// Get all
export const getProducts = async (req, res) => {
  const user = await prisma.user.findUnique({
    where: {
      id: req.user.id
    },
    include: {
      products: true // products are what we really want to query 
    }
  })

  res.json({data: user.products})
}

// Get one 
export const getOneProduct = async (req, res) => {
    const id = req.params.id

    const product = await prisma.product.findFirst({
        where: {
            id,
            belongsToId: req.user.id
        }
    })

    res.json({data: product})
}

export const createProduct = async (req, res) => {
    const product = await prisma.product.create({
        data: {
            name: req.body.name, 
            belongsToId: req.user.id
        }
    })

    res.json({data: product})
}

export const updateProduct = async (req, res) => {
    const updated = await prisma.product.update({
        where: {
            id_belongsToId: {
                id: req.params.id,
                belongsToId: req.user.id
            }
        },
        data: {
            name: req.body.name
        }
    })

    res.json({data: updated})
}

export const deleteProduct = async (req, res) => {
    const deleted = await prisma.product.delete({
        where: {
            id_belongsToId: {
                id: req.params.id,
                belongsToId: req.user.id
            }
        }
    })

    res.json({data: deleted})
}
```

## Middleware 
Middleware are functions that run right before your handlers run. They can do things like augment the request, log, handle errors, authenticate, etc. 
```js
const myMiddleware = (req, res, next) => {
  // ... do my work, and when I done call next()
  next();
}
```

### Third-party Middlewares
`morgan` A middleware that logs requests. 
`npm i morgan --save`
```js
import express from 'express'
import morgan from 'morgan'
import cors from 'cors'

const app = express()

app.use(cors()) // allow CORS 
app.use(morgan('dev'))
app.use(express.json()) // allow clients to send us JSON
app.use(express.urlencoded({extended: true})) // allow clients to add things like query string 'google.com?a=1,thing=otherthing'
```
How does the log looks like? 
`GET /api/product 200 1092.252 ms - 172`

### Creating a Custom Middleware 
```js
app.use((req, res, next) => {
    req.shhhh_secret = 'doggy' // add secret to request object, all routes will have access to 'doggy'
    next()
})
```
How does logger middleware execute when a request come in? 
A function returns another function. 
```js
const customLogger = (message) => (req, res, next) => {
  console.log(`Hello from ${message}`)
  next()
}

app.use(customLogger('customer logger'))
```

## Authentication 
Our DB is multitenant, we don't want one user having access to another user's data. So we need authentication to identify what user is making the request. 
### JWT 
JSON Web Token.  
Our API never stores a JWT, it's stored client side. 
`npm i jsonwebtoken bcrypt dotenv` 
Create `src/modules/auth.ts`
```ts
import jwt from 'jsonwebtoken'

export const createJWT = (user) => { // username is unique for each user
  const token = jwt.sign({id: user.id, username: user.username}, process.env.JWT_SECRET) // JWT_SECRET can be any string
  return token
}
```
By default, environment variables in `.env` doesn't get to load in our environment. 
`JWT_SECRET` will not load in our code. 
That's why we need to install `dotenv`.    
Prisma is able to load env variable because the `prisma` module does that work.    
Update `src/index.ts`
```ts
import * as dotenv from 'dotenv'
dotenv.config()

import app from './server'

app.listen(3001, () => {
    console.log('hello on http://localhost:3001')
})
```

### Protecting Routes 
Update `src/modules/auth.ts`
```ts
export const protect = (req, res, next) => {
  const bearer = req.headers.authorization

  if(!bearer) {
    res.status(401)
    res.json({message: 'not authorized'})
    return 
  }

  const [, token] = bearer.split(' ') // the first index is 'bearer'

  if(!token) {
    res.status(401)
    res.json({message: 'no token'})
    return 
  }

  try {
    const user = jwt.verify(token, process.env.JWT_SECRET)
    req.user = user 
    next()
  } catch (e) {
    console.error(e)
    res.status(401)
    res.json({message: 'not valid token'})
    return 
  }
}
```
Protect api routes
`/src/server.ts`
```ts
import { protect } from './modules/auth'

app.use('/api', protect, router)
```

### Hashing Passwords 
Update `src/modules/auth.ts`
```ts
import bcrypt from 'bcrypt'

// password: plain text from user, hash: encypt text from DB 
export const comparePasswords = (password, hash) => { 
  return bcrypt.compare(password, hash)  // bcrypt.compare is by default async, which returns a promise 
}

export const hashPassword = (password) => {
    return bcrypt.hash(password, 5) // 5 is the salt 
}
```

### Creating and Authenticating Users
Create `src/heandlers/user.ts`
```ts
import prisma from '../db'
import { comparePasswords, createJWT, hashPassword } from '../modules/auth'

export const createNewUser = async (req, res) => {
  const user = await prisma.user.create({
    data: {
      username: req.body.username,
      password: await hashPassword(req.body.password) 
    }
  })

  const token = createJWT(user)
  res.json({token}) // send JWT token back to user. 
}

export const signin = async (req, res) => {
  const user = await prisma.user.findUnique({
    where: {
      username: req.body.username
    }
  })

  const isValid = await comparePasswords(req.body.password, user.password)

  if(!isValid) {
    res.status(401)
    res.json({message: 'username or password invalid'})
    return 
  }

  const token = createJWT(user) // When signin, user also don't have a JWT token yet. 
  res.json({token})
}
```
Adding User Routes in `src/server.ts`
```ts
import { createNewUser, signin } from './handlers/user'

app.use('/api', protect, router)

app.post('/user', createNewUser)
app.post('/signin', signin)

export default app
```

## Validation
Validate user inputs, use middleware as validator.  
`npm i express-validator`
`src/router.ts`
```ts
import { body } from 'express-validator'
import { handleInputErrors } from './modules/middleware'

/**
 * Product
 */
router.put('product/:id', body('name').isString(), handleInputErrors, (req, res) => {}) // request body should have name field which is string type.
router.post('/product', body('name').isString(), handleInputErrors, (req, res) => {})

/**
 * Update
 */
router.put('/update/:id', 
  body('title').optional(), // it's optional since this is update, not create 
  body('body').optional(), 
  body('status').isIn(['IN_PROGRESS', 'SHIPPED', 'DEPRECATED']).optional(), 
  body('version').optional(), 
  (req, res) => {}
)
router.post('/update', 
  body('title').exists().isString(),
  body('body').exists().isString(),
  body('productId').exists().isString(),
  () => {}
)
```
Create `src/modules/middleware.ts`
```ts
import { validationResult } from 'express-validator'

export const handleInputErrors = (req, res, next) => {
  const errors = validationResult(req)

  if(!errors.isEmpty()) {
    res.status(400)
    res.json({ errors: errors.array() })
  } else {
    next()
  }
}
```
